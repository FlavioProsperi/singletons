Promote/LetStatements.hs:0:0: Splicing declarations
    promote
      [d| foo1 :: Nat -> Nat
          foo1 x
            = let
                y :: Nat
                y = Succ Zero
              in y
          foo2 :: Nat
          foo2
            = let
                y = Succ Zero
                z = Succ y
              in z
          foo3 :: Nat -> Nat
          foo3 x
            = let
                y :: Nat
                y = Succ x
              in y
          foo4 :: Nat -> Nat
          foo4 x
            = let
                f :: Nat -> Nat
                f y = Succ y
              in f x
          foo5 :: Nat -> Nat
          foo5 x
            = let
                f :: Nat -> Nat
                f y
                  = let
                      z :: Nat
                      z = Succ y
                    in Succ z
              in f x
          foo6 :: Nat -> Nat
          foo6 x
            = let
                f :: Nat -> Nat
                f y = Succ y in
              let
                z :: Nat
                z = f x
              in z
          foo7 :: Nat -> Nat
          foo7 x
            = let
                x :: Nat
                x = Zero
              in x
          foo8 :: Nat -> Nat
          foo8 x
            = let
                z :: Nat
                z = (\ x -> x) Zero
              in z
          foo9 :: Nat -> Nat
          foo9 x
            = let
                z :: Nat -> Nat
                z = (\ x -> x)
              in z x
          foo10 :: Nat -> Nat
          foo10 x
            = let
                (+) :: Nat -> Nat -> Nat
                Zero + m = m
                (Succ n) + m = Succ (n + m)
              in (Succ Zero) + x
          foo11 :: Nat -> Nat
          foo11 x
            = let
                (+) :: Nat -> Nat -> Nat
                Zero + m = m
                (Succ n) + m = Succ (n + m)
                z :: Nat
                z = x
              in (Succ Zero) + z
          foo12 :: Nat -> Nat
          foo12 x
            = let
                (+) :: Nat -> Nat -> Nat
                Zero + m = m
                (Succ n) + m = Succ (n + x)
              in x + (Succ (Succ Zero))
          foo13 :: forall a. a -> a
          foo13 x
            = let
                bar :: a
                bar = x
              in foo13b bar
          foo13b :: a -> a
          foo13b y = y |]
  ======>
    Promote/LetStatements.hs:(0,0)-(0,0)
    foo1 :: Nat -> Nat
    foo1 x
      = let
          y :: Nat
          y = Succ Zero
        in y
    foo2 :: Nat
    foo2
      = let
          y = Succ Zero
          z = Succ y
        in z
    foo3 :: Nat -> Nat
    foo3 x
      = let
          y :: Nat
          y = Succ x
        in y
    foo4 :: Nat -> Nat
    foo4 x
      = let
          f :: Nat -> Nat
          f y = Succ y
        in f x
    foo5 :: Nat -> Nat
    foo5 x
      = let
          f :: Nat -> Nat
          f y
            = let
                z :: Nat
                z = Succ y
              in Succ z
        in f x
    foo6 :: Nat -> Nat
    foo6 x
      = let
          f :: Nat -> Nat
          f y = Succ y in
        let
          z :: Nat
          z = f x
        in z
    foo7 :: Nat -> Nat
    foo7 x
      = let
          x :: Nat
          x = Zero
        in x
    foo8 :: Nat -> Nat
    foo8 x
      = let
          z :: Nat
          z = \ x -> x Zero
        in z
    foo9 :: Nat -> Nat
    foo9 x
      = let
          z :: Nat -> Nat
          z = \ x -> x
        in z x
    foo10 :: Nat -> Nat
    foo10 x
      = let
          (+) :: Nat -> Nat -> Nat
          (+) Zero m = m
          (+) (Succ n) m = Succ (n + m)
        in ((Succ Zero) + x)
    foo11 :: Nat -> Nat
    foo11 x
      = let
          (+) :: Nat -> Nat -> Nat
          z :: Nat
          (+) Zero m = m
          (+) (Succ n) m = Succ (n + m)
          z = x
        in ((Succ Zero) + z)
    foo12 :: Nat -> Nat
    foo12 x
      = let
          (+) :: Nat -> Nat -> Nat
          (+) Zero m = m
          (+) (Succ n) m = Succ (n + x)
        in (x + (Succ (Succ Zero)))
    foo13 :: forall a. a -> a
    foo13 x
      = let
          bar :: a
          bar = x
        in foo13b bar
    foo13b :: forall a. a -> a
    foo13b y = y
    type family Let_0123456789y (a :: x) :: Nat where
      Let_0123456789y x = Apply SuccSym0 ZeroSym0
    data Let_0123456789ySym0 (k :: TyFun x Nat)
    type instance Apply Let_0123456789ySym0 a = Let_0123456789y a
    type Foo2 = Let_0123456789zSym0
    type Foo2Sym0 = Foo2
    type Let_0123456789y = Apply SuccSym0 ZeroSym0
    type Let_0123456789ySym0 = Let_0123456789y
    type Let_0123456789z = Apply SuccSym0 Let_0123456789ySym0
    type Let_0123456789zSym0 = Let_0123456789z
    type family Let_0123456789y (a :: x) :: Nat where
      Let_0123456789y x = Apply SuccSym0 x
    data Let_0123456789ySym0 (k :: TyFun x Nat)
    type instance Apply Let_0123456789ySym0 a = Let_0123456789y a
    type family Let_0123456789f (a :: x) (a :: Nat) :: Nat where
      Let_0123456789f x y = Apply SuccSym0 y
    data Let_0123456789fSym1 (l :: x) (l :: TyFun Nat Nat)
    data Let_0123456789fSym0 (k :: TyFun x (TyFun Nat Nat -> *))
    type instance Apply (Let_0123456789fSym1 a) a = Let_0123456789f a a
    type instance Apply Let_0123456789fSym0 a = Let_0123456789fSym1 a
    type family Let_0123456789z (a :: x) (a :: y) :: Nat where
      Let_0123456789z x y = Apply SuccSym0 y
    data Let_0123456789zSym1 (l :: x) (l :: TyFun y Nat)
    data Let_0123456789zSym0 (k :: TyFun x (TyFun y Nat -> *))
    type instance Apply (Let_0123456789zSym1 a) a = Let_0123456789z a a
    type instance Apply Let_0123456789zSym0 a = Let_0123456789zSym1 a
    type family Let_0123456789f (a :: x) (a :: Nat) :: Nat where
      Let_0123456789f x y = Apply SuccSym0 (Apply (Apply Let_0123456789zSym0 x) y)
    data Let_0123456789fSym1 (l :: x) (l :: TyFun Nat Nat)
    data Let_0123456789fSym0 (k :: TyFun x (TyFun Nat Nat -> *))
    type instance Apply (Let_0123456789fSym1 a) a = Let_0123456789f a a
    type instance Apply Let_0123456789fSym0 a = Let_0123456789fSym1 a
    type family Let_0123456789f (a :: x) (a :: Nat) :: Nat where
      Let_0123456789f x y = Apply SuccSym0 y
    data Let_0123456789fSym1 (l :: x) (l :: TyFun Nat Nat)
    data Let_0123456789fSym0 (k :: TyFun x (TyFun Nat Nat -> *))
    type instance Apply (Let_0123456789fSym1 a) a = Let_0123456789f a a
    type instance Apply Let_0123456789fSym0 a = Let_0123456789fSym1 a
    type family Let_0123456789z (a :: x) :: Nat where
      Let_0123456789z x = Apply (Apply Let_0123456789fSym0 x) x
    data Let_0123456789zSym0 (k :: TyFun x Nat)
    type instance Apply Let_0123456789zSym0 a = Let_0123456789z a
    type family Let_0123456789x (a :: x) :: Nat where
      Let_0123456789x x = ZeroSym0
    data Let_0123456789xSym0 (k :: TyFun x Nat)
    type instance Apply Let_0123456789xSym0 a = Let_0123456789x a
    type family Lambda_0123456789 (x :: x) (t :: k) :: r where
      Lambda_0123456789 x x = x
    data Lambda_0123456789Sym1 (l :: x) (l :: TyFun k r)
    type instance Apply (Lambda_0123456789Sym1 a) a = Lambda_0123456789 a a
    type family Let_0123456789z (a :: x) :: Nat where
      Let_0123456789z x = Apply (Lambda_0123456789Sym1 x) ZeroSym0
    data Let_0123456789zSym0 (k :: TyFun x Nat)
    type instance Apply Let_0123456789zSym0 a = Let_0123456789z a
    type family Lambda_0123456789 (x :: x) (t :: k) :: r where
      Lambda_0123456789 x x = x
    data Lambda_0123456789Sym1 (l :: x) (l :: TyFun k r)
    type instance Apply (Lambda_0123456789Sym1 a) a = Lambda_0123456789 a a
    type family Let_0123456789z (a :: x) :: TyFun Nat Nat -> * where
      Let_0123456789z x = Lambda_0123456789Sym1 x
    data Let_0123456789zSym0 (k :: TyFun x (TyFun Nat Nat -> *))
    type instance Apply Let_0123456789zSym0 a = Let_0123456789z a
    type family Let_0123456789+ (a :: x)
                                (a :: Nat)
                                (a :: Nat) :: Nat where
      Let_0123456789+ x Zero m = m
      Let_0123456789+ x (Succ n) m = Apply SuccSym0 (Apply (Apply (Apply Let_0123456789+Sym0 x) n) m)
    data Let_0123456789+Sym2 (l :: x) (l :: Nat) (l :: TyFun Nat Nat)
    data Let_0123456789+Sym1 (l :: x)
                             (l :: TyFun Nat (TyFun Nat Nat -> *))
    data Let_0123456789+Sym0 (k :: TyFun x (TyFun Nat (TyFun Nat Nat
                                                       -> *)
                                            -> *))
    type instance Apply (Let_0123456789+Sym2 a a) a = Let_0123456789+ a a a
    type instance Apply (Let_0123456789+Sym1 a) a = Let_0123456789+Sym2 a a
    type instance Apply Let_0123456789+Sym0 a = Let_0123456789+Sym1 a
    type family Let_0123456789+ (a :: x)
                                (a :: Nat)
                                (a :: Nat) :: Nat where
      Let_0123456789+ x Zero m = m
      Let_0123456789+ x (Succ n) m = Apply SuccSym0 (Apply (Apply (Apply Let_0123456789+Sym0 x) n) m)
    data Let_0123456789+Sym2 (l :: x) (l :: Nat) (l :: TyFun Nat Nat)
    data Let_0123456789+Sym1 (l :: x)
                             (l :: TyFun Nat (TyFun Nat Nat -> *))
    data Let_0123456789+Sym0 (k :: TyFun x (TyFun Nat (TyFun Nat Nat
                                                       -> *)
                                            -> *))
    type instance Apply (Let_0123456789+Sym2 a a) a = Let_0123456789+ a a a
    type instance Apply (Let_0123456789+Sym1 a) a = Let_0123456789+Sym2 a a
    type instance Apply Let_0123456789+Sym0 a = Let_0123456789+Sym1 a
    type family Let_0123456789z (a :: x) :: Nat where
      Let_0123456789z x = x
    data Let_0123456789zSym0 (k :: TyFun x Nat)
    type instance Apply Let_0123456789zSym0 a = Let_0123456789z a
    type family Let_0123456789+ (a :: x)
                                (a :: Nat)
                                (a :: Nat) :: Nat where
      Let_0123456789+ x Zero m = m
      Let_0123456789+ x (Succ n) m = Apply SuccSym0 (Apply (Apply (Apply Let_0123456789+Sym0 x) n) x)
    data Let_0123456789+Sym2 (l :: x) (l :: Nat) (l :: TyFun Nat Nat)
    data Let_0123456789+Sym1 (l :: x)
                             (l :: TyFun Nat (TyFun Nat Nat -> *))
    data Let_0123456789+Sym0 (k :: TyFun x (TyFun Nat (TyFun Nat Nat
                                                       -> *)
                                            -> *))
    type instance Apply (Let_0123456789+Sym2 a a) a = Let_0123456789+ a a a
    type instance Apply (Let_0123456789+Sym1 a) a = Let_0123456789+Sym2 a a
    type instance Apply Let_0123456789+Sym0 a = Let_0123456789+Sym1 a
    type family Let_0123456789bar (a :: x) :: a where
      Let_0123456789bar x = x
    data Let_0123456789barSym0 (k :: TyFun x a)
    type instance Apply Let_0123456789barSym0 a = Let_0123456789bar a
    type family Foo1 (a :: Nat) :: Nat where
      Foo1 x = Apply Let_0123456789ySym0 x
    data Foo1Sym0 (k :: TyFun Nat Nat)
    type instance Apply Foo1Sym0 a = Foo1 a
    type family Foo3 (a :: Nat) :: Nat where
      Foo3 x = Apply Let_0123456789ySym0 x
    data Foo3Sym0 (k :: TyFun Nat Nat)
    type instance Apply Foo3Sym0 a = Foo3 a
    type family Foo4 (a :: Nat) :: Nat where
      Foo4 x = Apply (Apply Let_0123456789fSym0 x) x
    data Foo4Sym0 (k :: TyFun Nat Nat)
    type instance Apply Foo4Sym0 a = Foo4 a
    type family Foo5 (a :: Nat) :: Nat where
      Foo5 x = Apply (Apply Let_0123456789fSym0 x) x
    data Foo5Sym0 (k :: TyFun Nat Nat)
    type instance Apply Foo5Sym0 a = Foo5 a
    type family Foo6 (a :: Nat) :: Nat where
      Foo6 x = Apply Let_0123456789zSym0 x
    data Foo6Sym0 (k :: TyFun Nat Nat)
    type instance Apply Foo6Sym0 a = Foo6 a
    type family Foo7 (a :: Nat) :: Nat where
      Foo7 x = Apply Let_0123456789xSym0 x
    data Foo7Sym0 (k :: TyFun Nat Nat)
    type instance Apply Foo7Sym0 a = Foo7 a
    type family Foo8 (a :: Nat) :: Nat where
      Foo8 x = Apply Let_0123456789zSym0 x
    data Foo8Sym0 (k :: TyFun Nat Nat)
    type instance Apply Foo8Sym0 a = Foo8 a
    type family Foo9 (a :: Nat) :: Nat where
      Foo9 x = Apply (Apply Let_0123456789zSym0 x) x
    data Foo9Sym0 (k :: TyFun Nat Nat)
    type instance Apply Foo9Sym0 a = Foo9 a
    type family Foo10 (a :: Nat) :: Nat where
      Foo10 x = Apply (Apply (Apply Let_0123456789+Sym0 x) (Apply SuccSym0 ZeroSym0)) x
    data Foo10Sym0 (k :: TyFun Nat Nat)
    type instance Apply Foo10Sym0 a = Foo10 a
    type family Foo11 (a :: Nat) :: Nat where
      Foo11 x = Apply (Apply (Apply Let_0123456789+Sym0 x) (Apply SuccSym0 ZeroSym0)) (Apply Let_0123456789zSym0 x)
    data Foo11Sym0 (k :: TyFun Nat Nat)
    type instance Apply Foo11Sym0 a = Foo11 a
    type family Foo12 (a :: Nat) :: Nat where
      Foo12 x = Apply (Apply (Apply Let_0123456789+Sym0 x) x) (Apply SuccSym0 (Apply SuccSym0 ZeroSym0))
    data Foo12Sym0 (k :: TyFun Nat Nat)
    type instance Apply Foo12Sym0 a = Foo12 a
    type family Foo13 (a :: a) :: a where
      Foo13 x = Apply Foo13bSym0 (Apply Let_0123456789barSym0 x)
    data Foo13Sym0 (k :: TyFun a a)
    type instance Apply Foo13Sym0 a = Foo13 a
    type family Foo13b (a :: a) :: a where
      Foo13b y = y
    data Foo13bSym0 (k :: TyFun a a)
    type instance Apply Foo13bSym0 a = Foo13b a
