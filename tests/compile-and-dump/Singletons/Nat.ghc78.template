Singletons/Nat.hs:0:0: Splicing declarations
    singletons
      [d| data Nat
            where
              Zero :: Nat
              Succ :: Nat -> Nat
            deriving (Eq, Show, Read) |]
  ======>
    Singletons/Nat.hs:(0,0)-(0,0)
    data Nat
      = Zero | Succ Nat
      deriving (Eq, Show, Read)
    type family Equals_0123456789 (a :: Nat) (b :: Nat) :: Bool where
      Equals_0123456789 Zero Zero = TrueSym0
      Equals_0123456789 (Succ a) (Succ b) = (:==) a b
      Equals_0123456789 (a :: Nat) (b :: Nat) = FalseSym0
    instance PEq (KProxy :: KProxy Nat) where
      type (:==) (a :: Nat) (b :: Nat) = Equals_0123456789 a b
    type ZeroSym0 = Zero
    type SuccSym1 (t :: Nat) = Succ t
    instance SuppressUnusedWarnings SuccSym0 where
      suppressUnusedWarnings _
        = snd (GHC.Tuple.(,) SuccSym0KindInference GHC.Tuple.())
    data SuccSym0 (l :: TyFun Nat Nat)
      = forall arg. KindOf (Apply SuccSym0 arg) ~ KindOf (SuccSym1 arg) =>
        SuccSym0KindInference
    type instance Apply SuccSym0 l = SuccSym1 l
    data instance Sing (z :: Nat)
      = z ~ Zero => SZero |
        forall (n :: Nat). z ~ Succ n => SSucc (Sing n)
    type SNat (z :: Nat) = Sing z
    instance SingKind (KProxy :: KProxy Nat) where
      type DemoteRep (KProxy :: KProxy Nat) = Nat
      fromSing SZero = Zero
      fromSing (SSucc b) = Succ (fromSing b)
      toSing Zero = SomeSing SZero
      toSing (Succ b)
        = case toSing b :: SomeSing (KProxy :: KProxy Nat) of {
            SomeSing c -> SomeSing (SSucc c) }
    instance SEq (KProxy :: KProxy Nat) where
      (%:==) SZero SZero = STrue
      (%:==) SZero (SSucc _) = SFalse
      (%:==) (SSucc _) SZero = SFalse
      (%:==) (SSucc a) (SSucc b) = (%:==) a b
    instance SDecide (KProxy :: KProxy Nat) where
      (%~) SZero SZero = Proved Refl
      (%~) SZero (SSucc _)
        = Disproved
            (\ x
               -> case x of {
                    _ -> error "Empty case reached -- this should be impossible" })
      (%~) (SSucc _) SZero
        = Disproved
            (\ x
               -> case x of {
                    _ -> error "Empty case reached -- this should be impossible" })
      (%~) (SSucc a) (SSucc b)
        = case (%~) a b of {
            Proved Refl -> Proved Refl
            Disproved contra
              -> Disproved (\ refl -> case refl of { Refl -> contra Refl }) }
    instance SingI Zero where
      sing = SZero
    instance SingI n => SingI (Succ (n :: Nat)) where
      sing = SSucc sing
Singletons/Nat.hs:0:0: Splicing declarations
    singletons
      [d| plus :: Nat -> Nat -> Nat
          plus Zero m = m
          plus (Succ n) m = Succ (plus n m)
          pred :: Nat -> Nat
          pred Zero = Zero
          pred (Succ n) = n |]
  ======>
    Singletons/Nat.hs:(0,0)-(0,0)
    plus :: Nat -> Nat -> Nat
    plus Zero m = m
    plus (Succ n) m = Succ (plus n m)
    pred :: Nat -> Nat
    pred Zero = Zero
    pred (Succ n) = n
    type Let_0123456789NSym2 t t = Let_0123456789N t t
    instance SuppressUnusedWarnings Let_0123456789NSym1 where
      suppressUnusedWarnings _
        = snd (GHC.Tuple.(,) Let_0123456789NSym1KindInference GHC.Tuple.())
    data Let_0123456789NSym1 l l
      = forall arg. KindOf (Apply (Let_0123456789NSym1 l) arg) ~ KindOf (Let_0123456789NSym2 l arg) =>
        Let_0123456789NSym1KindInference
    type instance Apply (Let_0123456789NSym1 l) l = Let_0123456789NSym2 l l
    instance SuppressUnusedWarnings Let_0123456789NSym0 where
      suppressUnusedWarnings _
        = snd (GHC.Tuple.(,) Let_0123456789NSym0KindInference GHC.Tuple.())
    data Let_0123456789NSym0 l
      = forall arg. KindOf (Apply Let_0123456789NSym0 arg) ~ KindOf (Let_0123456789NSym1 arg) =>
        Let_0123456789NSym0KindInference
    type instance Apply Let_0123456789NSym0 l = Let_0123456789NSym1 l
    type Let_0123456789N _arg_0123456789 _n_0123456789 = _n_0123456789
    type family Case_0123456789 _arg_0123456789 t where
      Case_0123456789 _arg_0123456789 (Succ _n_0123456789) = Let_0123456789NSym2 _arg_0123456789 _n_0123456789
      Case_0123456789 _arg_0123456789 Zero = ZeroSym0
    type Let_0123456789NSym3 t t t = Let_0123456789N t t t
    instance SuppressUnusedWarnings Let_0123456789NSym2 where
      suppressUnusedWarnings _
        = snd (GHC.Tuple.(,) Let_0123456789NSym2KindInference GHC.Tuple.())
    data Let_0123456789NSym2 l l l
      = forall arg. KindOf (Apply (Let_0123456789NSym2 l l) arg) ~ KindOf (Let_0123456789NSym3 l l arg) =>
        Let_0123456789NSym2KindInference
    type instance Apply (Let_0123456789NSym2 l l) l = Let_0123456789NSym3 l l l
    instance SuppressUnusedWarnings Let_0123456789NSym1 where
      suppressUnusedWarnings _
        = snd (GHC.Tuple.(,) Let_0123456789NSym1KindInference GHC.Tuple.())
    data Let_0123456789NSym1 l l
      = forall arg. KindOf (Apply (Let_0123456789NSym1 l) arg) ~ KindOf (Let_0123456789NSym2 l arg) =>
        Let_0123456789NSym1KindInference
    type instance Apply (Let_0123456789NSym1 l) l = Let_0123456789NSym2 l l
    instance SuppressUnusedWarnings Let_0123456789NSym0 where
      suppressUnusedWarnings _
        = snd (GHC.Tuple.(,) Let_0123456789NSym0KindInference GHC.Tuple.())
    data Let_0123456789NSym0 l
      = forall arg. KindOf (Apply Let_0123456789NSym0 arg) ~ KindOf (Let_0123456789NSym1 arg) =>
        Let_0123456789NSym0KindInference
    type instance Apply Let_0123456789NSym0 l = Let_0123456789NSym1 l
    type Let_0123456789N _arg_0123456789
                         _arg_0123456789
                         _n_0123456789 =
        _n_0123456789
    type Let_0123456789MSym3 t t t = Let_0123456789M t t t
    instance SuppressUnusedWarnings Let_0123456789MSym2 where
      suppressUnusedWarnings _
        = snd (GHC.Tuple.(,) Let_0123456789MSym2KindInference GHC.Tuple.())
    data Let_0123456789MSym2 l l l
      = forall arg. KindOf (Apply (Let_0123456789MSym2 l l) arg) ~ KindOf (Let_0123456789MSym3 l l arg) =>
        Let_0123456789MSym2KindInference
    type instance Apply (Let_0123456789MSym2 l l) l = Let_0123456789MSym3 l l l
    instance SuppressUnusedWarnings Let_0123456789MSym1 where
      suppressUnusedWarnings _
        = snd (GHC.Tuple.(,) Let_0123456789MSym1KindInference GHC.Tuple.())
    data Let_0123456789MSym1 l l
      = forall arg. KindOf (Apply (Let_0123456789MSym1 l) arg) ~ KindOf (Let_0123456789MSym2 l arg) =>
        Let_0123456789MSym1KindInference
    type instance Apply (Let_0123456789MSym1 l) l = Let_0123456789MSym2 l l
    instance SuppressUnusedWarnings Let_0123456789MSym0 where
      suppressUnusedWarnings _
        = snd (GHC.Tuple.(,) Let_0123456789MSym0KindInference GHC.Tuple.())
    data Let_0123456789MSym0 l
      = forall arg. KindOf (Apply Let_0123456789MSym0 arg) ~ KindOf (Let_0123456789MSym1 arg) =>
        Let_0123456789MSym0KindInference
    type instance Apply Let_0123456789MSym0 l = Let_0123456789MSym1 l
    type Let_0123456789M _arg_0123456789
                         _arg_0123456789
                         _n_0123456789 =
        _arg_0123456789
    type Let_0123456789MSym2 t t = Let_0123456789M t t
    instance SuppressUnusedWarnings Let_0123456789MSym1 where
      suppressUnusedWarnings _
        = snd (GHC.Tuple.(,) Let_0123456789MSym1KindInference GHC.Tuple.())
    data Let_0123456789MSym1 l l
      = forall arg. KindOf (Apply (Let_0123456789MSym1 l) arg) ~ KindOf (Let_0123456789MSym2 l arg) =>
        Let_0123456789MSym1KindInference
    type instance Apply (Let_0123456789MSym1 l) l = Let_0123456789MSym2 l l
    instance SuppressUnusedWarnings Let_0123456789MSym0 where
      suppressUnusedWarnings _
        = snd (GHC.Tuple.(,) Let_0123456789MSym0KindInference GHC.Tuple.())
    data Let_0123456789MSym0 l
      = forall arg. KindOf (Apply Let_0123456789MSym0 arg) ~ KindOf (Let_0123456789MSym1 arg) =>
        Let_0123456789MSym0KindInference
    type instance Apply Let_0123456789MSym0 l = Let_0123456789MSym1 l
    type Let_0123456789M _arg_0123456789 _arg_0123456789 =
        _arg_0123456789
    type family Case_0123456789 _arg_0123456789 _arg_0123456789 t where
      Case_0123456789 _arg_0123456789 _arg_0123456789 (Succ _n_0123456789) = Apply SuccSym0 (Apply (Apply PlusSym0 (Let_0123456789NSym3 _arg_0123456789 _arg_0123456789 _n_0123456789)) (Let_0123456789MSym3 _arg_0123456789 _arg_0123456789 _n_0123456789))
      Case_0123456789 _arg_0123456789 _arg_0123456789 Zero = Let_0123456789MSym2 _arg_0123456789 _arg_0123456789
    type PredSym1 (t :: Nat) = Pred t
    instance SuppressUnusedWarnings PredSym0 where
      suppressUnusedWarnings _
        = snd (GHC.Tuple.(,) PredSym0KindInference GHC.Tuple.())
    data PredSym0 (l :: TyFun Nat Nat)
      = forall arg. KindOf (Apply PredSym0 arg) ~ KindOf (PredSym1 arg) =>
        PredSym0KindInference
    type instance Apply PredSym0 l = PredSym1 l
    type PlusSym2 (t :: Nat) (t :: Nat) = Plus t t
    instance SuppressUnusedWarnings PlusSym1 where
      suppressUnusedWarnings _
        = snd (GHC.Tuple.(,) PlusSym1KindInference GHC.Tuple.())
    data PlusSym1 (l :: Nat) (l :: TyFun Nat Nat)
      = forall arg. KindOf (Apply (PlusSym1 l) arg) ~ KindOf (PlusSym2 l arg) =>
        PlusSym1KindInference
    type instance Apply (PlusSym1 l) l = PlusSym2 l l
    instance SuppressUnusedWarnings PlusSym0 where
      suppressUnusedWarnings _
        = snd (GHC.Tuple.(,) PlusSym0KindInference GHC.Tuple.())
    data PlusSym0 (l :: TyFun Nat (TyFun Nat Nat -> *))
      = forall arg. KindOf (Apply PlusSym0 arg) ~ KindOf (PlusSym1 arg) =>
        PlusSym0KindInference
    type instance Apply PlusSym0 l = PlusSym1 l
    type family Pred (a :: Nat) :: Nat where
      Pred _arg_0123456789 = Case_0123456789 _arg_0123456789 _arg_0123456789
    type family Plus (a :: Nat) (a :: Nat) :: Nat where
      Plus _arg_0123456789 _arg_0123456789 = Case_0123456789 _arg_0123456789 _arg_0123456789 _arg_0123456789
    sPred :: forall (t :: Nat). Sing t -> Sing (Apply PredSym0 t)
    sPlus ::
      forall (t :: Nat) (t :: Nat).
      Sing t -> Sing t -> Sing (Apply (Apply PlusSym0 t) t)
    sPred _s_arg_0123456789
      = let
          lambda ::
            forall _arg_0123456789. t ~ _arg_0123456789 =>
            Sing _arg_0123456789 -> Sing (Apply PredSym0 _arg_0123456789)
          lambda _arg_0123456789
            = case _arg_0123456789 of {
                SSucc _s_n_0123456789
                  -> let
                       lambda ::
                         forall _n_0123456789. Apply SuccSym0 _n_0123456789 ~ _arg_0123456789 =>
                         Sing _n_0123456789
                         -> Sing (Case_0123456789 _arg_0123456789 (Apply SuccSym0 _n_0123456789))
                       lambda _n_0123456789
                         = let
                             sN :: Sing (Let_0123456789NSym2 _arg_0123456789 _n_0123456789)
                             sN = _n_0123456789
                           in sN
                     in lambda _s_n_0123456789
                SZero
                  -> let
                       lambda ::
                         ZeroSym0 ~ _arg_0123456789 =>
                         Sing (Case_0123456789 _arg_0123456789 ZeroSym0)
                       lambda = SZero
                     in lambda } ::
                Sing (Case_0123456789 _arg_0123456789 _arg_0123456789)
        in lambda _s_arg_0123456789
    sPlus _s_arg_0123456789 _s_arg_0123456789
      = let
          lambda ::
            forall _arg_0123456789 _arg_0123456789. (t ~ _arg_0123456789,
                                                     t ~ _arg_0123456789) =>
            Sing _arg_0123456789
            -> Sing _arg_0123456789
               -> Sing (Apply (Apply PlusSym0 _arg_0123456789) _arg_0123456789)
          lambda _arg_0123456789 _arg_0123456789
            = case _arg_0123456789 of {
                SSucc _s_n_0123456789
                  -> let
                       lambda ::
                         forall _n_0123456789. Apply SuccSym0 _n_0123456789 ~ _arg_0123456789 =>
                         Sing _n_0123456789
                         -> Sing (Case_0123456789 _arg_0123456789 _arg_0123456789 (Apply SuccSym0 _n_0123456789))
                       lambda _n_0123456789
                         = let
                             sN ::
                               Sing (Let_0123456789NSym3 _arg_0123456789 _arg_0123456789 _n_0123456789)
                             sN = _n_0123456789 in
                           let
                             sM ::
                               Sing (Let_0123456789MSym3 _arg_0123456789 _arg_0123456789 _n_0123456789)
                             sM = _arg_0123456789
                           in
                             applySing
                               (singFun1 (Proxy :: Proxy SuccSym0) SSucc)
                               (applySing
                                  (applySing (singFun2 (Proxy :: Proxy PlusSym0) sPlus) sN) sM)
                     in lambda _s_n_0123456789
                SZero
                  -> let
                       lambda ::
                         ZeroSym0 ~ _arg_0123456789 =>
                         Sing (Case_0123456789 _arg_0123456789 _arg_0123456789 ZeroSym0)
                       lambda
                         = let
                             sM :: Sing (Let_0123456789MSym2 _arg_0123456789 _arg_0123456789)
                             sM = _arg_0123456789
                           in sM
                     in lambda } ::
                Sing (Case_0123456789 _arg_0123456789 _arg_0123456789 _arg_0123456789)
        in lambda _s_arg_0123456789 _s_arg_0123456789
