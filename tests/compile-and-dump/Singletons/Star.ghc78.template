Singletons/Star.hs:0:0: Splicing declarations
    singletonStar [''Nat, ''Int, ''String, ''Maybe, ''Vec]
  ======>
    Singletons/Star.hs:0:0:
    data Rep
      = Singletons.Star.Nat |
        Singletons.Star.Int |
        Singletons.Star.String |
        Singletons.Star.Maybe Rep |
        Singletons.Star.Vec Rep Nat
      deriving (Eq, Show, Read)
    instance SDecide (KProxy :: KProxy *) where
      (%~) SNat SNat = Proved Refl
      (%~) SNat SInt
        = Disproved
            (\ x
               -> case x of {
                    _ -> error "Empty case reached -- this should be impossible" })
      (%~) SNat SString
        = Disproved
            (\ x
               -> case x of {
                    _ -> error "Empty case reached -- this should be impossible" })
      (%~) SNat (SMaybe _)
        = Disproved
            (\ x
               -> case x of {
                    _ -> error "Empty case reached -- this should be impossible" })
      (%~) SNat (SVec _ _)
        = Disproved
            (\ x
               -> case x of {
                    _ -> error "Empty case reached -- this should be impossible" })
      (%~) SInt SNat
        = Disproved
            (\ x
               -> case x of {
                    _ -> error "Empty case reached -- this should be impossible" })
      (%~) SInt SInt = Proved Refl
      (%~) SInt SString
        = Disproved
            (\ x
               -> case x of {
                    _ -> error "Empty case reached -- this should be impossible" })
      (%~) SInt (SMaybe _)
        = Disproved
            (\ x
               -> case x of {
                    _ -> error "Empty case reached -- this should be impossible" })
      (%~) SInt (SVec _ _)
        = Disproved
            (\ x
               -> case x of {
                    _ -> error "Empty case reached -- this should be impossible" })
      (%~) SString SNat
        = Disproved
            (\ x
               -> case x of {
                    _ -> error "Empty case reached -- this should be impossible" })
      (%~) SString SInt
        = Disproved
            (\ x
               -> case x of {
                    _ -> error "Empty case reached -- this should be impossible" })
      (%~) SString SString = Proved Refl
      (%~) SString (SMaybe _)
        = Disproved
            (\ x
               -> case x of {
                    _ -> error "Empty case reached -- this should be impossible" })
      (%~) SString (SVec _ _)
        = Disproved
            (\ x
               -> case x of {
                    _ -> error "Empty case reached -- this should be impossible" })
      (%~) (SMaybe _) SNat
        = Disproved
            (\ x
               -> case x of {
                    _ -> error "Empty case reached -- this should be impossible" })
      (%~) (SMaybe _) SInt
        = Disproved
            (\ x
               -> case x of {
                    _ -> error "Empty case reached -- this should be impossible" })
      (%~) (SMaybe _) SString
        = Disproved
            (\ x
               -> case x of {
                    _ -> error "Empty case reached -- this should be impossible" })
      (%~) (SMaybe a) (SMaybe b)
        = case (%~) a b of {
            Proved Refl -> Proved Refl
            Disproved contra
              -> Disproved (\ refl -> case refl of { Refl -> contra Refl }) }
      (%~) (SMaybe _) (SVec _ _)
        = Disproved
            (\ x
               -> case x of {
                    _ -> error "Empty case reached -- this should be impossible" })
      (%~) (SVec _ _) SNat
        = Disproved
            (\ x
               -> case x of {
                    _ -> error "Empty case reached -- this should be impossible" })
      (%~) (SVec _ _) SInt
        = Disproved
            (\ x
               -> case x of {
                    _ -> error "Empty case reached -- this should be impossible" })
      (%~) (SVec _ _) SString
        = Disproved
            (\ x
               -> case x of {
                    _ -> error "Empty case reached -- this should be impossible" })
      (%~) (SVec _ _) (SMaybe _)
        = Disproved
            (\ x
               -> case x of {
                    _ -> error "Empty case reached -- this should be impossible" })
      (%~) (SVec a a) (SVec b b)
        = case GHC.Tuple.(,) ((%~) a b) ((%~) a b) of {
            GHC.Tuple.(,) (Proved Refl) (Proved Refl) -> Proved Refl
            GHC.Tuple.(,) (Disproved contra) _
              -> Disproved (\ refl -> case refl of { Refl -> contra Refl })
            GHC.Tuple.(,) _ (Disproved contra)
              -> Disproved (\ refl -> case refl of { Refl -> contra Refl }) }
    instance SEq (KProxy :: KProxy *) where
      (%:==) a b
        = case (%~) a b of {
            Proved Refl -> STrue
            Disproved _ -> Unsafe.Coerce.unsafeCoerce SFalse }
    data instance Sing (z :: *)
      = (GHC.Types.~) z Nat => SNat |
        (GHC.Types.~) z Int => SInt |
        (GHC.Types.~) z String => SString |
        forall (n :: *). (GHC.Types.~) z (Maybe n) => SMaybe (Sing n) |
        forall (n :: *) (n :: Nat). (GHC.Types.~) z (Vec n n) =>
        SVec (Sing n) (Sing n)
    type SRep (z :: *) = Sing z
    instance SingKind (KProxy :: KProxy *) where
      type DemoteRep (KProxy :: KProxy *) = Rep
      fromSing SNat = Singletons.Star.Nat
      fromSing SInt = Singletons.Star.Int
      fromSing SString = Singletons.Star.String
      fromSing (SMaybe b) = Singletons.Star.Maybe (fromSing b)
      fromSing (SVec b b) = Singletons.Star.Vec (fromSing b) (fromSing b)
      toSing Singletons.Star.Nat = SomeSing SNat
      toSing Singletons.Star.Int = SomeSing SInt
      toSing Singletons.Star.String = SomeSing SString
      toSing (Singletons.Star.Maybe b)
        = case toSing b :: SomeSing (KProxy :: KProxy *) of {
            SomeSing c -> SomeSing (SMaybe c) }
      toSing (Singletons.Star.Vec b b)
        = case
              GHC.Tuple.(,)
                (toSing b :: SomeSing (KProxy :: KProxy *))
                (toSing b :: SomeSing (KProxy :: KProxy Nat))
          of {
            GHC.Tuple.(,) (SomeSing c) (SomeSing c) -> SomeSing (SVec c c) }
    instance SingI Nat where
      sing = SNat
    instance SingI Int where
      sing = SInt
    instance SingI String where
      sing = SString
    instance SingI n => SingI (Maybe (n :: *)) where
      sing = SMaybe sing
    instance (SingI n, SingI n) =>
             SingI (Vec (n :: *) (n :: Nat)) where
      sing = SVec sing sing
