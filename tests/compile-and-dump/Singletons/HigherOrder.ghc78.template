Singletons/HigherOrder.hs:0:0: Splicing declarations
    singletons
      [d| map :: (a -> b) -> [a] -> [b]
          map _ [] = []
          map f (h : t) = (f h) : (map f t)
          liftMaybe :: (a -> b) -> Maybe a -> Maybe b
          liftMaybe f (Just x) = Just (f x)
          liftMaybe _ Nothing = Nothing
          zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
          zipWith f (x : xs) (y : ys) = f x y : zipWith f xs ys
          zipWith _ [] [] = []
          zipWith _ (_ : _) [] = []
          zipWith _ [] (_ : _) = []
          foo_ :: ((a -> b) -> a -> b) -> (a -> b) -> a -> b
          foo_ f g a = f g a

          data Either a b = Left a | Right b |]
  ======>
    Singletons/HigherOrder.hs:(0,0)-(0,0)
    data Either a b = Left a | Right b
    map :: forall a b. (a -> b) -> [a] -> [b]
    map _ GHC.Types.[] = []
    map f (h GHC.Types.: t) = ((f h) GHC.Types.: (map f t))
    liftMaybe :: forall a b. (a -> b) -> Maybe a -> Maybe b
    liftMaybe f (Just x) = Just (f x)
    liftMaybe _ Nothing = Nothing
    zipWith :: forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
    zipWith f (x GHC.Types.: xs) (y GHC.Types.: ys)
      = ((f x y) GHC.Types.: (zipWith f xs ys))
    zipWith _ GHC.Types.[] GHC.Types.[] = []
    zipWith _ (_ GHC.Types.: _) GHC.Types.[] = []
    zipWith _ GHC.Types.[] (_ GHC.Types.: _) = []
    foo_ :: forall a b. ((a -> b) -> a -> b) -> (a -> b) -> a -> b
    foo_ f g a = f g a
    type EitherTyCtor = Either
    data EitherTyCtorSym1 (l :: *) (l :: TyFun * *)
    data EitherTyCtorSym0 (k :: TyFun * (TyFun * * -> *))
    type instance Apply (EitherTyCtorSym1 a) a = EitherTyCtor a a
    type instance Apply EitherTyCtorSym0 a = EitherTyCtorSym1 a
    data LeftSym0 (k :: TyFun a (Either a b))
    type instance Apply LeftSym0 a = Left a
    data RightSym0 (k :: TyFun b (Either a b))
    type instance Apply RightSym0 a = Right a
    type family Map (a :: TyFun a b -> *) (a :: [a]) :: [b] where
      Map z GHC.Types.[] = '[]
      Map f ((GHC.Types.:) h t) = Apply (Apply (:$) (Apply f h)) (Apply (Apply MapSym0 f) t)
    data MapSym1 (l :: TyFun a b -> *) (l :: TyFun [a] [b])
    data MapSym0 (k :: TyFun (TyFun a b -> *) (TyFun [a] [b] -> *))
    type instance Apply (MapSym1 a) a = Map a a
    type instance Apply MapSym0 a = MapSym1 a
    type family LiftMaybe (a :: TyFun a b -> *)
                          (a :: Maybe a) :: Maybe b where
      LiftMaybe f (Just x) = Apply JustSym0 (Apply f x)
      LiftMaybe z Nothing = NothingSym0
    data LiftMaybeSym1 (l :: TyFun a b -> *)
                       (l :: TyFun (Maybe a) (Maybe b))
    data LiftMaybeSym0 (k :: TyFun (TyFun a b
                                    -> *) (TyFun (Maybe a) (Maybe b) -> *))
    type instance Apply (LiftMaybeSym1 a) a = LiftMaybe a a
    type instance Apply LiftMaybeSym0 a = LiftMaybeSym1 a
    type family ZipWith (a :: TyFun a (TyFun b c -> *) -> *)
                        (a :: [a])
                        (a :: [b]) :: [c] where
      ZipWith f ((GHC.Types.:) x xs) ((GHC.Types.:) y ys) = Apply (Apply (:$) (Apply (Apply f x) y)) (Apply (Apply (Apply ZipWithSym0 f) xs) ys)
      ZipWith z GHC.Types.[] GHC.Types.[] = '[]
      ZipWith z ((GHC.Types.:) z z) GHC.Types.[] = '[]
      ZipWith z GHC.Types.[] ((GHC.Types.:) z z) = '[]
    data ZipWithSym2 (l :: TyFun a (TyFun b c -> *) -> *)
                     (l :: [a])
                     (l :: TyFun [b] [c])
    data ZipWithSym1 (l :: TyFun a (TyFun b c -> *) -> *)
                     (l :: TyFun [a] (TyFun [b] [c] -> *))
    data ZipWithSym0 (k :: TyFun (TyFun a (TyFun b c -> *)
                                  -> *) (TyFun [a] (TyFun [b] [c] -> *) -> *))
    type instance Apply (ZipWithSym2 a a) a = ZipWith a a a
    type instance Apply (ZipWithSym1 a) a = ZipWithSym2 a a
    type instance Apply ZipWithSym0 a = ZipWithSym1 a
    type family Foo_ (a :: TyFun (TyFun a b -> *) (TyFun a b -> *)
                           -> *)
                     (a :: TyFun a b -> *)
                     (a :: a) :: b where
      Foo_ f g a = Apply (Apply f g) a
    data Foo_Sym2 (l :: TyFun (TyFun a b -> *) (TyFun a b -> *) -> *)
                  (l :: TyFun a b -> *)
                  (l :: TyFun a b)
    data Foo_Sym1 (l :: TyFun (TyFun a b -> *) (TyFun a b -> *) -> *)
                  (l :: TyFun (TyFun a b -> *) (TyFun a b -> *))
    data Foo_Sym0 (k :: TyFun (TyFun (TyFun a b -> *) (TyFun a b -> *)
                               -> *) (TyFun (TyFun a b -> *) (TyFun a b -> *) -> *))
    type instance Apply (Foo_Sym2 a a) a = Foo_ a a a
    type instance Apply (Foo_Sym1 a) a = Foo_Sym2 a a
    type instance Apply Foo_Sym0 a = Foo_Sym1 a
    data instance Sing (z :: Either a b)
      = forall (n :: a). z ~ Left n => SLeft (Sing n) |
        forall (n :: b). z ~ Right n => SRight (Sing n)
    type SEither (z :: Either a b) = Sing z
    instance (SingKind (KProxy :: KProxy a),
              SingKind (KProxy :: KProxy b)) =>
             SingKind (KProxy :: KProxy (Either a b)) where
      type DemoteRep (KProxy :: KProxy (Either a b)) = Either (DemoteRep (KProxy :: KProxy a)) (DemoteRep (KProxy :: KProxy b))
      fromSing (SLeft b) = Left (fromSing b)
      fromSing (SRight b) = Right (fromSing b)
      toSing (Left b)
        = case toSing b :: SomeSing (KProxy :: KProxy a) of {
            SomeSing c -> SomeSing (SLeft c) }
      toSing (Right b)
        = case toSing b :: SomeSing (KProxy :: KProxy b) of {
            SomeSing c -> SomeSing (SRight c) }
    instance SingI n => SingI (Left (n :: a)) where
      sing = SLeft sing
    instance SingI n => SingI (Right (n :: b)) where
      sing = SRight sing
    sMap ::
      forall (t :: TyFun a b -> *) (t :: [a]).
      (forall (t :: a). Data.Proxy.Proxy t -> Sing t -> Sing (Apply t t))
      -> Sing t -> Sing (Map t t)
    sMap _ SNil = SNil
    sMap f (SCons h t) = SCons (f Data.Proxy.Proxy h) (sMap f t)
    sLiftMaybe ::
      forall (t :: TyFun a b -> *) (t :: Maybe a).
      (forall (t :: a). Data.Proxy.Proxy t -> Sing t -> Sing (Apply t t))
      -> Sing t -> Sing (LiftMaybe t t)
    sLiftMaybe f (SJust x) = SJust (f Data.Proxy.Proxy x)
    sLiftMaybe _ SNothing = SNothing
    sZipWith ::
      forall (t :: TyFun a (TyFun b c -> *) -> *) (t :: [a]) (t :: [b]).
      (forall (t :: a) (t :: b).
       Data.Proxy.Proxy t
       -> Sing t -> Sing t -> Sing (Apply (Apply t t) t))
      -> Sing t -> Sing t -> Sing (ZipWith t t t)
    sZipWith f (SCons x xs) (SCons y ys)
      = SCons (f Data.Proxy.Proxy x y) (sZipWith f xs ys)
    sZipWith _ SNil SNil = SNil
    sZipWith _ (SCons _ _) SNil = SNil
    sZipWith _ SNil (SCons _ _) = SNil
    sFoo_ ::
      forall (t :: TyFun (TyFun a b -> *) (TyFun a b -> *) -> *)
             (t :: TyFun a b -> *)
             (t :: a).
      (forall (t :: TyFun a b -> *) (t :: a).
       Data.Proxy.Proxy t
       -> (forall (t :: a).
           Data.Proxy.Proxy t -> Sing t -> Sing (Apply t t))
          -> Sing t -> Sing (Apply (Apply t t) t))
      -> (forall (t :: a).
          Data.Proxy.Proxy t -> Sing t -> Sing (Apply t t))
         -> Sing t -> Sing (Foo_ t t t)
    sFoo_ f g a = f Data.Proxy.Proxy g a
