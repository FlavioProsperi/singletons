Singletons/HigherOrder.hs:0:0: Splicing declarations
    singletons
      [d| map :: (a -> b) -> [a] -> [b]
          map _ [] = []
          map f (h : t) = (f h) : (map f t)
          liftMaybe :: (a -> b) -> Maybe a -> Maybe b
          liftMaybe f (Just x) = Just (f x)
          liftMaybe _ Nothing = Nothing
          zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
          zipWith f (x : xs) (y : ys) = f x y : zipWith f xs ys
          zipWith _ [] [] = []
          foo :: ((a -> b) -> a -> b) -> (a -> b) -> a -> b
          foo f g a = f g a |]
  ======>
    Singletons/HigherOrder.hs:(0,0)-(0,0)
    map :: forall a b. (a -> b) -> [a] -> [b]
    map _ GHC.Types.[] = []
    map f (h GHC.Types.: t) = ((f h) GHC.Types.: (map f t))
    liftMaybe :: forall a b. (a -> b) -> Maybe a -> Maybe b
    liftMaybe f (Just x) = Just (f x)
    liftMaybe _ Nothing = Nothing
    zipWith :: forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
    zipWith f (x GHC.Types.: xs) (y GHC.Types.: ys)
      = ((f x y) GHC.Types.: (zipWith f xs ys))
    zipWith _ GHC.Types.[] GHC.Types.[] = []
    foo :: forall a b. ((a -> b) -> a -> b) -> (a -> b) -> a -> b
    foo f g a = f g a
    type family Map (a :: TyFun a b -> *) (a :: [a]) :: [b] where
         Map z GHC.Types.[] = '[]
         Map f ((GHC.Types.:) h t) = (@@) ((@@) (::$) ((@@) f h)) ((@@) ((@@) MapSym0 f) t)
    data MapSym1 (l :: TyFun a b -> *) (l :: TyFun [a] [b])
    data MapSym0 (k :: TyFun (TyFun a b -> *) (TyFun [a] [b] -> *))
    type instance (@@) (MapSym1 a) a = Map a a
    type instance (@@) MapSym0 a = MapSym1 a
    type family LiftMaybe (a :: TyFun a b -> *)
                          (a :: Maybe a) :: Maybe b where
         LiftMaybe f (Just x) = (@@) JustSym0 ((@@) f x)
         LiftMaybe z Nothing = NothingSym0
    data LiftMaybeSym1 (l :: TyFun a b -> *)
                       (l :: TyFun (Maybe a) (Maybe b))
    data LiftMaybeSym0 (k :: TyFun (TyFun a b
                                    -> *) (TyFun (Maybe a) (Maybe b) -> *))
    type instance (@@) (LiftMaybeSym1 a) a = LiftMaybe a a
    type instance (@@) LiftMaybeSym0 a = LiftMaybeSym1 a
    type family ZipWith (a :: TyFun a (TyFun b c -> *) -> *)
                        (a :: [a])
                        (a :: [b]) :: [c] where
      ZipWith f ((GHC.Types.:) x xs) ((GHC.Types.:) y ys) = (@@) ((@@) (::$) ((@@) ((@@) f x) y)) ((@@) ((@@) ((@@) ZipWithSym0 f) xs) ys)
      ZipWith z GHC.Types.[] GHC.Types.[] = '[]
    data ZipWithSym2 (l :: TyFun a (TyFun b c -> *) -> *)
                     (l :: [a])
                     (l :: TyFun [b] [c])
    data ZipWithSym1 (l :: TyFun a (TyFun b c -> *) -> *)
                     (l :: TyFun [a] (TyFun [b] [c] -> *))
    data ZipWithSym0 (k :: TyFun (TyFun a (TyFun b c -> *)
                                  -> *) (TyFun [a] (TyFun [b] [c] -> *) -> *))
    type instance (@@) (ZipWithSym2 a a) a = ZipWith a a a
    type instance (@@) (ZipWithSym1 a) a = ZipWithSym2 a a
    type instance (@@) ZipWithSym0 a = ZipWithSym1 a
    type family Foo (a :: TyFun (TyFun a b -> *) (TyFun a b -> *) -> *)
                    (a :: TyFun a b -> *)
                    (a :: a) :: b where
      Foo f g a = (@@) ((@@) f g) a
    data FooSym2 (l :: TyFun (TyFun a b -> *) (TyFun a b -> *) -> *)
                 (l :: TyFun a b -> *)
                 (l :: TyFun a b)
    data FooSym1 (l :: TyFun (TyFun a b -> *) (TyFun a b -> *) -> *)
                 (l :: TyFun (TyFun a b -> *) (TyFun a b -> *))
    data FooSym0 (k :: TyFun (TyFun (TyFun a b -> *) (TyFun a b -> *)
                              -> *) (TyFun (TyFun a b -> *) (TyFun a b -> *) -> *))
    type instance (@@) (FooSym2 a a) a = Foo a a a
    type instance (@@) (FooSym1 a) a = FooSym2 a a
    type instance (@@) FooSym0 a = FooSym1 a
    sMap ::
      forall (t :: TyFun a b -> *) (t :: [a]).
      (forall (t :: a). Proxy t -> Sing t -> Sing ((@@) t t))
      -> Sing t -> Sing (Map t t)
    sMap _ SNil = SNil
    sMap f (SCons h t) = SCons (f Proxy h) (sMap f t)
    sLiftMaybe ::
      forall (t :: TyFun a b -> *) (t :: Maybe a).
      (forall (t :: a). Proxy t -> Sing t -> Sing ((@@) t t))
      -> Sing t -> Sing (LiftMaybe t t)
    sLiftMaybe f (SJust x) = SJust (f Proxy x)
    sLiftMaybe _ SNothing = SNothing
    sZipWith ::
      forall (t :: TyFun a (TyFun b c -> *) -> *) (t :: [a]) (t :: [b]).
      (forall (t :: a) (t :: b).
       Proxy t -> Sing t -> Sing t -> Sing ((@@) ((@@) t t) t))
      -> Sing t -> Sing t -> Sing (ZipWith t t t)
    sZipWith f (SCons x xs) (SCons y ys)
      = SCons (f Proxy x y) (sZipWith f xs ys)
    sZipWith _ SNil SNil = SNil
    sFoo ::
      forall (t :: TyFun (TyFun a b -> *) (TyFun a b -> *) -> *)
             (t :: TyFun a b -> *)
             (t :: a).
      (forall (t :: TyFun a b -> *) (t :: a).
       Proxy t
       -> (forall (t :: a). Proxy t -> Sing t -> Sing ((@@) t t))
          -> Sing t -> Sing ((@@) ((@@) t t) t))
      -> (forall (t :: a). Proxy t -> Sing t -> Sing ((@@) t t))
         -> Sing t -> Sing (Foo t t t)
    sFoo f g a = f Proxy g a
